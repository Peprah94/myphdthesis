for(i in 1:nspecies){
data_det_spframe[[i]] <- SpatialPointsDataFrame(rndpts, data = data.frame(detection_data[[i]]))
names(data_det_spframe[[i]])<-paste0("detdata",i)
}
## the borders of the study region
coordsmat <- matrix(c(0,0,3,0,3,3,0,3,0,0),ncol=2,byrow=T)
poly <- SpatialPolygons(list(Polygons(list(Polygon(coordsmat)),ID=1)))
## the mesh
mesh <- inla.mesh.2d(loc.domain = coordsmat, offset = c(0.3, 1),
max.edge = c(0.1, 0.5), cutoff = 0.2)
## SPDEs definition
spdes <- list()
for(i in 1: nspecies){
spdes[[i]] <- inla.spde2.pcmatern(mesh = mesh,
# PC-prior on range: P(practic.range < 0.05) = 0.01
prior.range = c(input$ecological$hyperparameters$range[i], 0.5),
# PC-prior on sigma: P(sigma > 1) = 0.01
prior.sigma = c(sqrt(input$ecological$hyperparameters$sigma2[i]), 0.5))
}
#SPDEs for the thinning
spde2 <- inla.spde2.pcmatern(mesh = mesh,
# PC-prior on range: P(practic.range < 0.05) = 0.01
prior.range = c(input$sampling$hyperparameters$range, 0.5),
# PC-prior on sigma: P(sigma > 1) = 0.01
prior.sigma = c(sqrt(input$sampling$hyperparameters$sigma2), 0.5))
csdata = simulateddata$thirdstage
cssampdata = simulateddata$firststage$Samp_PPFinal
detdata = data_det_spframe
covslist <- list(cov1.spix,cov2.spix,cov3.spix)
spdeslist <- list(spdes=spdes,spde2=spde2)
covs = covslist
region=poly
mesh=mesh
data_df <- data.frame(
Y = csdata$classifications$error,
C = csdata$classifications$true_species,
eco_cov = extract(cov1.rast,csdata$classifications),
samp_cov= extract(cov2.rast,csdata$classifications),
det_cov = extract(cov3.rast,csdata$classifications))
#Testing the compiled function.
#Should give the same results as fit.inla
CnimbleINLA <- compileNimble(nimbleINLADataGenerating)
class_prob <- matrix(c(0.9, 0.1,
0.05, 0.95),
nrow=2, ncol=2, byrow = TRUE)
# Running INLA within NIMBLE
cnt <- 0
listout <- list()
code <-nimbleCode({
for(i in 1:nspecies){
omega[i, 1:nspecies] ~ ddirch(alpha = alpha[1:nspecies])
}
r[1:nsite,1:20] <- nimbleINLADataGenerating(omega[1:nspecies,1:nspecies]) #change 38 to a constant to be specified
for(i in 1:nsite){
# for(j in 1:nspecies){
log(lambda_obs[i,1]) <- r[i,5] + r[i,6]*true_cov[i] + r[i,11]+
r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12] - log(1+exp(r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12])) +
r[i, 9] + r[i,10]*det_cov[i] - log(1+exp(r[i, 9] + r[i,10]*det_cov[i]))
# Second species
log(lambda_obs[i,2]) <- r[i,13] + r[i,14]*true_cov[i] + r[i,19]+
r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20] - log(1+exp(r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20])) +
r[i, 17] + r[i,18]*det_cov[i] - log(1+exp(r[i, 17] + r[i,18]*det_cov[i]))
}
lambda[1:nsite, 1:nspecies] <- lambda_obs[1:nsite, 1:nspecies]
#Proportion of lambdas
# Proportion for the multinomial distribution
for(site.tag in 1:nsite){
for(spe.tag in 1:nspecies){
prop[site.tag,spe.tag] <- (lambda[site.tag, spe.tag])/sum(lambda[site.tag, 1:nspecies])
}
}
# True data
for(site.tag in 1:nsite){
C[site.tag] ~ dcat(prop[site.tag,1:nspecies])
}
# Reported species
for(site.tag in 1:nsite){
Y[site.tag] ~ dcat(omega[C[site.tag],1:nspecies])
}
})
#Data
inla_data <- list(Y=data_df$Y,
C = data_df$C,
true_cov = data_df$eco_cov,
bias_cov=data_df$samp_cov,
det_cov= data_df$det_cov)
#Constants
const <- list(nspecies=length(unique(data_df$C)),
nsite = length(data_df$C),
alpha=rep(1, length(unique(data_df$C)))
)
# Initial values
idm_inits <- function(){list(omega = matrix(c(0.99, 0.01,
0.01, 0.99),
nrow=2, ncol=2, byrow = TRUE)
)
}
devtools::load_all(".")
# Running INLA within NIMBLE
cnt <- 0
listout <- list()
code <-nimbleCode({
for(i in 1:nspecies){
omega[i, 1:nspecies] ~ ddirch(alpha = alpha[1:nspecies])
}
r[1:nsite,1:20] <- nimbleINLADataGenerating(omega[1:nspecies,1:nspecies]) #change 38 to a constant to be specified
for(i in 1:nsite){
# for(j in 1:nspecies){
log(lambda_obs[i,1]) <- r[i,5] + r[i,6]*true_cov[i] + r[i,11]+
r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12] - log(1+exp(r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12])) +
r[i, 9] + r[i,10]*det_cov[i] - log(1+exp(r[i, 9] + r[i,10]*det_cov[i]))
# Second species
log(lambda_obs[i,2]) <- r[i,13] + r[i,14]*true_cov[i] + r[i,19]+
r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20] - log(1+exp(r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20])) +
r[i, 17] + r[i,18]*det_cov[i] - log(1+exp(r[i, 17] + r[i,18]*det_cov[i]))
}
lambda[1:nsite, 1:nspecies] <- lambda_obs[1:nsite, 1:nspecies]
#Proportion of lambdas
# Proportion for the multinomial distribution
for(site.tag in 1:nsite){
for(spe.tag in 1:nspecies){
prop[site.tag,spe.tag] <- (lambda[site.tag, spe.tag])/sum(lambda[site.tag, 1:nspecies])
}
}
# True data
for(site.tag in 1:nsite){
C[site.tag] ~ dcat(prop[site.tag,1:nspecies])
}
# Reported species
for(site.tag in 1:nsite){
Y[site.tag] ~ dcat(omega[C[site.tag],1:nspecies])
}
})
#Data
inla_data <- list(Y=data_df$Y,
C = data_df$C,
true_cov = data_df$eco_cov,
bias_cov=data_df$samp_cov,
det_cov= data_df$det_cov)
#Constants
const <- list(nspecies=length(unique(data_df$C)),
nsite = length(data_df$C),
alpha=rep(1, length(unique(data_df$C)))
)
# Initial values
idm_inits <- function(){list(omega = matrix(c(0.99, 0.01,
0.01, 0.99),
nrow=2, ncol=2, byrow = TRUE)
)
}
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 50,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
load("estimates.RData")
inlanim$output
model = mcmcconf$model
## node list generation
targetAsScalar <- model$expandNodeNames(target, returnScalarComponents = TRUE)
calcNodes <- model$getDependencies(target)
targetAsScalar
calcNodes <- model$getDependencies(target)
calcNodes
calcNodesNoSelf <- model$getDependencies(target, self = FALSE)
isStochCalcNodesNoSelf <- model$isStoch(calcNodesNoSelf)   ## should be made faster
calcNodesNoSelfDeterm <- calcNodesNoSelf[!isStochCalcNodesNoSelf]
calcNodesNoSelfStoch <- calcNodesNoSelf[isStochCalcNodesNoSelf]
## numeric value generation
# d <- length(targetAsScalar)
expandTarget <- model$expandNodeNames(target)
expandTarget
d <- length(model$expandNodeNames(target))
dr <- length(targetAsScalar)/d
thetaVec <- rep(0,dr)
thetaVec1 <- rep(0,dr)
scaleVec         <- rep(scaleOriginal, d)
scaleVec1         <- rep(scaleOriginal, d)
timesRan         <- 0
timesRan1         <- 0
timesAcceptedVec <- rep(0, d)
timesAcceptedVec1 <- rep(0, d)
timesAdapted     <- 0
timesAdapted1     <- 0
optimalAR        <- 0.44
optimalAR1        <- 0.44
gamma1           <- 0
gamma2           <- 0
target <- expandTarget[1]
target1 <- expandTarget[2]
target2 <- expandTarget[1]
target1 <- expandTarget[2]
devtools::load_all(".")
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 50,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
sampler_BASE <- nimble::nimbleFunctionVirtual(
name = 'sampler_BASE',
methods = list(
reset = function() { }
)
)
myRW_dirichlet <- myRW_dirichlet <- nimble::nimbleFunction(
name = 'myRW_dirichlet',
contains = sampler_BASE,
setup = function(model, mvSaved, target, control) {
## control list extraction
adaptive            <- extractControlElement(control, 'adaptive',            TRUE)
adaptInterval       <- extractControlElement(control, 'adaptInterval',       200)
adaptFactorExponent <- extractControlElement(control, 'adaptFactorExponent', 0.8)
scaleOriginal       <- extractControlElement(control, 'scale',               1)
## node list generation
targetAsScalar <- model$expandNodeNames(target, returnScalarComponents = TRUE)
calcNodes <- model$getDependencies(target)
calcNodesNoSelf <- model$getDependencies(target, self = FALSE)
isStochCalcNodesNoSelf <- model$isStoch(calcNodesNoSelf)   ## should be made faster
calcNodesNoSelfDeterm <- calcNodesNoSelf[!isStochCalcNodesNoSelf]
calcNodesNoSelfStoch <- calcNodesNoSelf[isStochCalcNodesNoSelf]
## numeric value generation
# d <- length(targetAsScalar)
expandTarget <- model$expandNodeNames(target)
d <- length(model$expandNodeNames(target))
dr <- length(targetAsScalar)/d
#  thetaVec         <- matrix(rep(0, d*dr), nrow = dr)
thetaVec <- rep(0,dr)
thetaVec1 <- rep(0,dr)
scaleVec         <- rep(scaleOriginal, d)
scaleVec1         <- rep(scaleOriginal, d)
timesRan         <- 0
timesRan1         <- 0
timesAcceptedVec <- rep(0, d)
timesAcceptedVec1 <- rep(0, d)
timesAdapted     <- 0
timesAdapted1     <- 0
optimalAR        <- 0.44
optimalAR1        <- 0.44
gamma1           <- 0
gamma2           <- 0
target2 <- expandTarget[1]
target1 <- expandTarget[2]
## checks
#if(length(model$expandNodeNames(target)) > 1)    stop('RW_dirichlet sampler only applies to one target node')
#if(model$getDistribution(target) != 'ddirch')    stop('can only use RW_dirichlet sampler for dirichlet distributions')
},
run = function() {
eldf <- model$calculateDiff(calcNodesNoSelf)
for(j in 1:dr){
if(j == 1){
if(thetaVec[1] == 0)   thetaVec <<- values(model, target2)   ## initialization
alphaVec <- model$getParam(target2, 'alpha')
for(i in 1:d) {
currentValue <- thetaVec[i]
propLogScale <- rnorm(1, mean = 0, sd = scaleVec[i])
propValue <- currentValue * exp(propLogScale)
if(propValue != 0) {
thetaVecProp <- thetaVec
thetaVecProp[i] <- propValue
values(model, target2) <<- thetaVecProp / sum(thetaVecProp)
logMHR <- alphaVec[i]*propLogScale + currentValue - propValue + eldf
jump <- decide(logMHR)
} else jump <- FALSE
if(adaptive & jump)   timesAcceptedVec[i] <<- timesAcceptedVec[i] + 1
if(jump) {
thetaVec <<- thetaVecProp
nimCopy(from = model, to = mvSaved, row = 1, nodes = target2, logProb = TRUE)
nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodesNoSelfDeterm, logProb = FALSE)
nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodesNoSelfStoch, logProbOnly = TRUE)
} else {
nimCopy(from = mvSaved, to = model, row = 1, nodes = target2, logProb = TRUE)
nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodesNoSelfDeterm, logProb = FALSE)
nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodesNoSelfStoch, logProbOnly = TRUE)
}
model$calculate(target)                                                             ## update target logProb
nimCopy(from = model, to = mvSaved, row = 1, nodes = target2, logProbOnly = TRUE)    ##
}
if(adaptive) {
timesRan <<- timesRan + 1
if(timesRan %% adaptInterval == 0) {
acceptanceRateVec <- timesAcceptedVec / timesRan
timesAdapted <<- timesAdapted + 1
gamma1 <<- 1/((timesAdapted + 3)^adaptFactorExponent)
adaptFactorVec <- exp(10 * gamma1 * (acceptanceRateVec - optimalAR))
scaleVec <<- scaleVec * adaptFactorVec
timesRan <<- 0
timesAcceptedVec <<- numeric(d, 0)
}
}
}
if(j ==2){
if(thetaVec1[1] == 0)   thetaVec1 <<- values(model, target1)   ## initialization
alphaVec <- model$getParam(target1, 'alpha')
for(i in 1:d) {
currentValue <- thetaVec1[i]
propLogScale <- rnorm(1, mean = 0, sd = scaleVec[i])
propValue <- currentValue * exp(propLogScale)
if(propValue != 0) {
thetaVecProp <- thetaVec1
thetaVecProp[i] <- propValue
values(model, target1) <<- thetaVecProp / sum(thetaVecProp)
logMHR <- alphaVec[i]*propLogScale + currentValue - propValue + eldf
jump <- decide(logMHR)
} else jump <- FALSE
if(adaptive & jump)   timesAcceptedVec1[i] <<- timesAcceptedVec1[i] + 1
if(jump) {
thetaVec <<- thetaVecProp
nimCopy(from = model, to = mvSaved, row = 1, nodes = target1, logProb = TRUE)
nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodesNoSelfDeterm, logProb = FALSE)
nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodesNoSelfStoch, logProbOnly = TRUE)
} else {
nimCopy(from = mvSaved, to = model, row = 1, nodes = target1, logProb = TRUE)
nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodesNoSelfDeterm, logProb = FALSE)
nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodesNoSelfStoch, logProbOnly = TRUE)
}
model$calculate(target)                                                             ## update target logProb
nimCopy(from = model, to = mvSaved, row = 1, nodes = target1, logProbOnly = TRUE)    ##
}
if(adaptive) {
timesRan1 <<- timesRan + 1
if(timesRan %% adaptInterval == 0) {
acceptanceRateVec1 <- timesAcceptedVec1 / timesRan
timesAdapted1 <<- timesAdapted1 + 1
gamma2 <<- 1/((timesAdapted1 + 3)^adaptFactorExponent)
adaptFactorVec <- exp(10 * gamma1 * (acceptanceRateVec1 - optimalAR1))
scaleVec1 <<- scaleVec1 * adaptFactorVec
timesRan1 <<- 0
timesAcceptedVec1 <<- numeric(d, 0)
}
}
}
}
},
methods = list(
reset = function() {
thetaVec         <<- numeric(d, 0)
thetaVec1         <<- numeric(d, 0)
scaleVec         <<- numeric(d, scaleOriginal)
scaleVec1         <<- numeric(d, scaleOriginal)
timesRan         <<- 0
timesRan1         <<- 0
timesAcceptedVec <<- numeric(d, 0)
timesAcceptedVec1 <<- numeric(d, 0)
timesAdapted     <<- 0
timesAdapted1     <<- 0
gamma1           <<- 0
gamma2           <<- 0
}
)
)
assign('myRW_dirichlet', myRW_dirichlet, envir = .GlobalEnv)
dmydirch <- nimble::nimbleFunction(
run = function(x = double(1), alpha = double(1),
log = integer(0, default = 0)) {
returnType(double(0))
logProb <- sum(lgamma(alpha)) - lgamma(sum(alpha)) +
sum((alpha -1) * log(x))
if(log) return(logProb)
else return(exp(logProb))
})
rmydirch <- nimble::nimbleFunction(
run = function(n = integer(0), alpha = double(1)) {
returnType(double(1))
if(n != 1) print("rdirch only allows n = 1; using n = 1.")
p <- rdirch(1, alpha)
return(p)
})
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 5,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
inlanim$output
inlanim$mcmc.out$summary
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 50,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
inlanim$mcmc.out$summary
devtools::load_all(".")
cnt = 0
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 10,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
# Running INLA within NIMBLE
cnt <- 0
listout <- list()
code <-nimbleCode({
for(i in 1:nspecies){
omega[i, 1:nspecies] ~ ddirch(alpha = alpha[1:nspecies])
}
r[1:nsite,1:20] <- nimbleINLADataGenerating(omega[1:nspecies,1:nspecies]) #change 38 to a constant to be specified
for(i in 1:nsite){
# for(j in 1:nspecies){
log(lambda_obs[i,1]) <- r[i,5] + r[i,6]*true_cov[i] + r[i,11]+
r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12] - log(1+exp(r[i, 7] + r[i,8]*bias_cov[i]+ r[i,12])) +
r[i, 9] + r[i,10]*det_cov[i] - log(1+exp(r[i, 9] + r[i,10]*det_cov[i]))
# Second species
log(lambda_obs[i,2]) <- r[i,13] + r[i,14]*true_cov[i] + r[i,19]+
r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20] - log(1+exp(r[i, 15] + r[i,16]*bias_cov[i]+ r[i,20])) +
r[i, 17] + r[i,18]*det_cov[i] - log(1+exp(r[i, 17] + r[i,18]*det_cov[i]))
}
lambda[1:nsite, 1:nspecies] <- lambda_obs[1:nsite, 1:nspecies]
#Proportion of lambdas
# Proportion for the multinomial distribution
for(site.tag in 1:nsite){
for(spe.tag in 1:nspecies){
prop[site.tag,spe.tag] <- (lambda[site.tag, spe.tag])/sum(lambda[site.tag, 1:nspecies])
}
}
# True data
for(site.tag in 1:nsite){
C[site.tag] ~ dcat(prop[site.tag,1:nspecies])
}
# Reported species
for(site.tag in 1:nsite){
Y[site.tag] ~ dcat(omega[C[site.tag],1:nspecies])
}
})
#Data
inla_data <- list(Y=data_df$Y,
C = data_df$C,
true_cov = data_df$eco_cov,
bias_cov=data_df$samp_cov,
det_cov= data_df$det_cov)
#Constants
const <- list(nspecies=length(unique(data_df$C)),
nsite = length(data_df$C),
alpha=rep(1, length(unique(data_df$C)))
)
# Initial values
idm_inits <- function(){list(omega = matrix(c(0.99, 0.01,
0.01, 0.99),
nrow=2, ncol=2, byrow = TRUE)
)
}
cnt = 0
inlanim = INLAWiNimDataGenerating(data = data_df,
code = code,
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
fam = "nogaussian",
parametersToMonitor = c("omega"),
mcmcConfiguration =  list(n.chains = 1,
n.iterations = 5,
n.burnin = 0,
n.thin = 1,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE))
inlanim$mcmc.out$summary
